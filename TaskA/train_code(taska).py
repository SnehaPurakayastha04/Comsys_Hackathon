# -*- coding: utf-8 -*-
"""Train_Code(TaskA).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gHP7UEniPGUVsrfsTnTDSly2Zzd94X7h
"""

#train # âœ… Install dependencies (if needed)
!pip install torch torchvision matplotlib --quiet

import os
import torch
import torchvision
import torchvision.transforms as transforms
from torchvision import datasets, models
from torch.utils.data import DataLoader
import torch.nn as nn
import torch.optim as optim
from torchvision.models import ResNet50_Weights
import matplotlib.pyplot as plt

# âœ… Paths (Change if needed)
train_dir = '/content/drive/MyDrive/Comys_Hackathon5/Comys_Hackathon5/Task_A/train'
val_dir = '/content/drive/MyDrive/Comys_Hackathon5/Comys_Hackathon5/Task_A/val'

# âœ… Transforms
transform_train = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(15),
    transforms.ColorJitter(brightness=0.3, contrast=0.3),
    transforms.RandomApply([transforms.GaussianBlur(3)], p=0.2),
    transforms.ToTensor(),
    transforms.Normalize([0.5]*3, [0.5]*3)
])

transform_val = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize([0.5]*3, [0.5]*3)
])

# âœ… Data Loaders
train_dataset = datasets.ImageFolder(train_dir, transform=transform_train)
val_dataset = datasets.ImageFolder(val_dir, transform=transform_val)
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)

# âœ… Model Setup
model = models.resnet50(weights=ResNet50_Weights.DEFAULT)
num_features = model.fc.in_features
model.fc = nn.Sequential(
    nn.Linear(num_features, 256),
    nn.ReLU(),
    nn.Dropout(0.5),
    nn.Linear(256, 2)
)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)

# âœ… Loss, Optimizer, Scheduler
criterion = nn.CrossEntropyLoss(label_smoothing=0.1)
optimizer = optim.AdamW(model.parameters(), lr=1e-4)
scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.5)

# âœ… Training Loop
best_acc = 0
patience = 4
wait = 0
epochs = 20

for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

    scheduler.step()

    # âœ… Validation
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for inputs, labels in val_loader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    val_acc = 100 * correct / total
    print(f"Epoch {epoch+1}: Loss={running_loss/len(train_loader):.4f}, Val Accuracy={val_acc:.2f}%")

    if val_acc > best_acc:
        best_acc = val_acc
        wait = 0
        torch.save(model.state_dict(), '/content/best_gender_model.pth')  # âœ… Save to Colab path
    else:
        wait += 1
        if wait >= patience:
            print("Early stopping.")
            break

print(f"Best Validation Accuracy: {best_acc:.2f}%")

# âœ… Evaluate Train & Val sets
def evaluate(loader, name):
    model.eval()
    preds, labels_all = [], []
    with torch.no_grad():
        for inputs, labels in loader:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model(inputs)
            _, predicted = torch.max(outputs, 1)
            preds.extend(predicted.cpu().numpy())
            labels_all.extend(labels.cpu().numpy())
    acc = accuracy_score(labels_all, preds)
    prec = precision_score(labels_all, preds, average='weighted')
    rec = recall_score(labels_all, preds, average='weighted')
    f1 = f1_score(labels_all, preds, average='weighted')
    print(f"\nðŸ“Š {name} Metrics:")
    print(f"Accuracy : {acc:.4f}")
    print(f"Precision: {prec:.4f}")
    print(f"Recall   : {rec:.4f}")
    print(f"F1-Score : {f1:.4f}")

evaluate(train_loader, "Train")
evaluate(val_loader, "Validation")